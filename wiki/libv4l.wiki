#summary This page presents libv4, a C library used to smooth out differences between the 2 V4L APIs
#labels Featured

=Introduction=
*Providing seamless access to V4L devices from user space isn't an easy task.*

First, video capture in Linux is done through the V4L API of the Linux kernel, which comes in two (incompatible) versions 1 (now deprecated) and 2. Which version of V4L is used depends on the hardware device itself and its driver. To this date, there are still a few V4L1-only drivers out there. The problem is that the semantics and usage of the two APIs is different. Usual tasks involved in capturing frames (setting up the video device, intialising capture buffers, and so on) are done in different ways, using different data structures and ioctl calls.

Second, there are several ways to control a video device, which again, depends on which version of V4L is used: 
 * through specific ioctls (VIDIOCGPICT and VIDIOCSPICT) for V4L1,
 * through [http://v4l2spec.bytesex.org/spec-single/v4l2.html#CONTROL user] and [http://v4l2spec.bytesex.org/spec-single/v4l2.html#EXTENDED-CONTROLS extended] V4L2 controls (for V4L2),
 *  through private ioctls (for both versions)
Usage of V4L1 VIDIOCGPICT ioctl is fairly simple but very limited in what it can control (brightnes, hue, color, contrast and whiteness). Normal V4L2 controls are also easy to enumerate and use. Both are well documented in the [http://linuxtv.org/downloads/video4linux/API/V4L1_API.html V4L1] and [http://v4l2spec.bytesex.org/spec-single/v4l2.html#CONTROL V4L2] specifications. However, private ioctls are hard to deal with. First, because it is not possible to discover or enumerate them at run-time. Second, because they are driver-dependent, meaning that one driver may implement a certain set of private iotcls, while another may implement a totally different one. The only way to make use of private ioctls is by:
 * hardcoding in the application ALL existing private ioctls for ALL drivers, and
 * have the application to try and detect the underlying driver. 
The former requires checking every single existing driver to find out whether or not it defines private ioctls, while the latter can not easily be done and again depends on which version of V4L is used.
Last, different video devices support different image formats. An image format defines how bytes are organised in an image buffer returned by V4L. It specifies the layout of the image in the buffer. There are [http://v4l2spec.bytesex.org/spec/c2030.htm *MANY* different image formats out there] and a few color spaces also.

Back to my first point: *Providing seamless access to V4L devices from user space isn't an easy task.* This is why instead of creating java code to directly interact with V4L, I have created an intermediate layer: libv4l. v4l4j relies on libv4l to "smooth out" the rough edges of dealing with V4L. 

=Features=
libv4l is a C library of functions which facilitates interactions with the capture interface of the V4L API. libv4l masks the differences between V4L1 and V4L2 and provides a unique API regardless of which version of V4L is used underneath.
 * It automatically detects the V4L version and adjusts itself consequently.
 * It offers image format negotiation by allowing the application to provide a set of acceptable image formats.
 * It automatically detects all controls (V4L1, user and extended V4L2 controls) and reports them as [http://v4l2spec.bytesex.org/spec/r13317.htm#V4L2-QUERYCTRL V4L2 controls]
 * It holds a list of drivers with private ioctls. It will automatically detects the underlying driver and reports any private iotcls also as (fake) [http://v4l2spec.bytesex.org/spec/r13317.htm#V4L2-QUERYCTRL V4L2 controls].
In essence, libv4l acts as an adapter for both version of V4L, and in turns offer in uniform API to capture frames using V4L.
I recently came accross another project with somewhat similar goals:
Hans de Goede has been working on a project also named [http://hansdegoede.livejournal.com/3636.html libv4l]. It is also a set of user-space libraries whose main goals are:
 * to allow existing V4L1 applications to work with V4L2 devices (by helping with image format conversion among other things)
 * to facilitate image format negotiation by transparently converting image formats to suit the application's needs. However, there is no provision to report driver-specific private ioctls.

=Tested Hardware=
See TestedHardware page

=Download=
libv4l is included in v4l4j, in the libv4l/ subdirectory.
If you want to download only libv4l (not the entire v4l4j project), use the following command:
{{{
svn co http://v4l4j.googlecode.com/svn/v4l4j/trunk/libv4l libv4l
}}}

=Requirements=
libv4l requires make, gcc and a V4L-supported video source. libv4l has been successfully compiled with gcc 4.2.3 and gcc 4.1.2

=Build=
Run "make" in the libv4l/ directory

=Usage=
libv4l is a library and is meant to be linked to an application. However, two test programs are shipped:
 * 'test-capture', which runs a capture from a given video device at a given resolution. It then prints the frame rate. It can also dump raw captured frames to files.
 * 'list-caps' which lists information about a given video device.
To compile the test programs, run "make test" in libv4l/.
The libv4l/example/ directory contains light_cap, a lighweight application which captures frames and sends them out as a multipart JPEG stream suitable for viewing in <img> tags of any standard-compliant web browser (no java applet required). See example/README for more details.

=Debugging=
libv4l contains lots of debug statements which are disable by default. To enable them, edit the Makefile, uncomment the line #DEBUG line and recompile libv4l. Extra output will be produced to allows troubleshooting.

=Issues=
Feedback is is greatly appreciated, specially because libv4l has only been tested with a very limited number of webcams and capture cards.
Issues and queries can be emailed to the [http://groups.google.com/group/v4l4j v4l4j mailing list] along with a description of what went wrong (or right) and what hardware you run libv4l on. Also, to facilitate troubleshooting, enable debugging (see DEBUGGING section above) and run the following 3 commands (replace videoXX with the right device file):
{{{
make clean test
./list-caps /dev/videoXX > list_caps_output 2>&1
./test-capture /dev/videoXX > test_cap_output 2>&1
}}}
Attach both "list_caps_output" and "test_cap_output" files to your query.


=libv4l API=
*libv4l is NOT reentrant ! Only one thread should call libv4l methods at any time.* The application using libv4l is responsible for implementing a proper locking mechanism.
See libv4l/test.c for a simple capture example.
Basically, to capture frames, you need to:
 * Include the right header files
{{{
#include "libv4l.h"
#include "palettes.h"
}}}
 * Initialise libv4l. You specify which video device file is to be used, the desired width and height, the input channel and standard and the desired number of buffers to be allocated. This method only checks that the device file exists and is readable. The other parameters will be applied when calling the next method. This method also detects which V4L version is used by the device and sets the member of the returned struct capture_device accordingly.
{{{
struct capture_device *c;
c = init_libv4l(video_device_file, width, height ,channel, std, nb_buf);
if(c==NULL) {
	printf("Error initialising device.\n");
	return -1;
}
}}}

 * Set the capture parameters. This method takes an array of desired image formats (see libv4l.h for a list of supported formats). Calling this method will try to apply the capture formats given in init_libv4l() and each of the specified image formats will be tried successively until a match is found. The selected image format is then available in c->palette.
{{{
int formats[] = {JPEG, MJPEG, YUV420, RGB24, YUYV};
int nb_formats = 5
if((*c->capture.set_cap_param)(c, formats, 5)){
	del_libv4l(c);
	printf("Cant set capture parameters\n");
	return -1;
}

printf("Capturing from %s at %dx%d.\n", c->file, c->width,c->height);
printf("Image format %s, size: %d\n", libv4l_palettes[c->palette].name, c->imagesize);
}}}
 Note that if set_cap_param() fails but init_libv4l() succeeded, you must call del_libv4l() to free resources.

 * Intialise V4L buffers.
{{{
if((*c->capture.init_capture)(c)<0){
	del_libv4l(c);
	printf("Cant initialise capture ");
	return -1;
}
}}}

 * Start the capture. This method should be called only when your application is ready to handle captured frames.
{{{
if((*c->capture.start_capture)(c)<0){
	(*c->capture.free_capture)(c);
	del_libv4l(c);
	printf("Cant start capture");
	return -1;
}
}}}
	
 * Capture frames, do something useful with them and let libv4l know when you are done with the buffer.
{{{
int size; //will contain the size of the captured frame 
void *d; //the buffer containing the frame

if((d = (*c->capture.dequeue_buffer)(c, &size)) != NULL) {

	//do something with buffer at "d" of length "size"

	//return buffer to libv4l
	(*c->capture.enqueue_buffer)(c);

} else {
	printf("Cant get buffer ");
	break;
}
}}}

 * Stop capture. This method must be called if start_capture() was successful.
{{{
if((*c->capture.stop_capture)(c)<0)
	printf("Error stopping capture\n");
}}}

 * Free V4L buffers. This method must be called if init_capture() was successful.
{{{
(*c->capture.free_capture)(c);
}}}

 * Free libv4l resources. This method must be called if init_liv4l() was successful
{{{
del_libv4l(c);
}}}