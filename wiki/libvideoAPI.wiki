#summary this page presents the libvideo API

Information on libvideo is split across multiple pages:

 * The [libvideo libvideo] page gives a short introduction to libvideo and how it came about.
 * The DownloadBuildUsage page explains how to download it, compile it and use it.
 * The [libvideoAPI API] page (this page) explains how to write a program with libvideo.

=libvideo API=
*libvideo is NOT reentrant ! Only one thread should call libvideo methods at any time.* The application using libvideo is responsible for implementing a proper locking mechanism.

The libvideo API is divided in five categories (or interfaces):
 # *The video device interface*. This is the main interface which is used to acquire other interfaces,
 # <a href="#The_Capture_interface">*The capture interface*</a> used to capture images from the device,
 # *The control interface* used to access video controls,
 # *The query interface* used to gather information on the video device,
 # *The tuner interface* used to control tuners on the video device.
An interface provides a set of methods related in functionality. Using an interface is a two step process: 
 * you first *acquire the interface* you want to access by calling the right method on the main interface (video device). You can then use this interface.
 * when you are done, you must *release the interface* by calling the appropriate method on the main interface.
Interfaces are independent from each other and can be used regardless of which other interfaces are currently acquired.

= Header files = 
The main header file is `libvideo.h` and contains all user-side required structures, function definitions and macros. `palettes.h` contains the definitions of an array of `struct libvideo_palette` which can be used to translate a libvideo palette index to its textual name. `livideo-err.h` contains all the macro definitions for returned values representing error codes.

= The Video Device interface =

This is the main interface from which all other interfaces are obtained. The video device interface is represented by a `struct video_device` which has the following members:
{{{
struct video_device {
	int fd;  //do not touch

#define V4L1_VERSION	1
#define V4L2_VERSION	2
	int v4l_version;  //specifies the version of V4L used by the device

#define FILENAME_LENGTH	99 + 1
	char file[FILENAME_LENGTH]; //contains the full path to the device file
	struct device_info *info;  //query interface structure
	struct capture_device *capture;  //capture interface structure
	struct control_list *control;  //control interface structure
	struct tuner_actions *tuner_action; //tuner interface structure
};
}}}
All members in this structure are read-only. the `info`, `capture`, `control` and `tuner_action` members point to structures representing other interfaces. These members are set to NULL, until the interface is acquired by calling the appropriate function, as detailled below.

To acquire the video device interface, do the following:
{{{
char device[] = "/dev/video0";
struct video_device *video_dev = open_device(device);
//check return value and take appropriate action

//when done:
if(close_device(video_dev)!=0)
    printf("Error: video device still in use\n");
}}}

`open_device()` initialises the video device & returns a pointer to a `struct video_device` or `NULL` if there is an error opening the device, if the given device file is not a video device, or if there is an error detecting the version of V4L.

`close_device()` releases resources and frees the `struct video_device` pointer, provided that all other interfaces have been released. If not, it returns LIBVIDEO_ERR_INFO_IN_USE, LIBVIDEO_ERR_CAPTURE_IN_USE, LIBVIDEO_ERR_CONTROL_IN_USE, LIBVIDEO_ERR_TUNER_IN_USE (these are defined in `libvideo-err.h`).

= The Capture interface =

This interface is represented by a `struct capture_device`, which contains the following members:
{{{
//all the fields in the following structure are read only
struct capture_device {
	struct mmap *mmap;  //do not touch
	int palette;  //which palette is used. see #define above
	int width;   //captured frame width
	int height;  //captured frame width
	int std;   //v4l standard 
	int channel;  //channel number (0 for webcams)
	int imagesize;  //in bytes
	int tuner_nb;  //the index of the tuner associated with
                       //this capture_device, -1 if not tuner input
	struct capture_actions *actions;  //see def below
	int is_native;  //this field is meaningful only with v4l2.
			//for v4l1, it is always set to 1.
                        //it specifies whether or not the palette
                        //is native, ie, whether it is produced by the device
                        //or it is converted by libvideo to a convienience format
	int real_v4l1_palette;  //do not touch
	struct convert_data* convert;	//do not touch
};
}}}
All the fields in this structure are read-only. Their values is manipulated by using appropriate functions in the capture interface. A pointer to a fully initialised `struct capture_device` is returned by the `init_capture_device(struct video_device *vdev, int w, int h, int ch, int s, int nb_buf)` function like this:
{{{
struct capture_device *cap = init_capture_device(video_dev, 640, 480,0, 0, 4);
//check returned value
}}}
This method allocates the structure, setups its members and returns it, or NULL if video_device is NULL. w is the desired capture width, h the desired capture height, ch is the input channel, s the video standard (WEBCAM, PAL, SECAM or NTSC) anb nb_buf is the number of buffers to be allocated (4 is an appropriate value) for capture. At this stage, the structure is initialised with the values given in arguments. It does not reflect the values that will be used for capture.

The structure must be released when finished with:
{{{
free_capture_device(cap);
}}}

Video capture involves the following steps:
 # apply capture parameters
 # intialise capture resources
 # start the capture
 # get the buffer with the latest frame
 # do something with the frame
 # put the buffer back
 # stop the capture
 # free resources

Steps 4,5 & 6 are repeated as many times as required to produce a video stream. Each of these steps is carried out using a specific method found in the `struct capture_actions` present in the `actions` member of the `struct capture_device`.

== Apply capture parameters ==
This step allows the application to specify a list of image formats it wishes to use. This is done using the `set_cap_param` member:
{{{
int fmts[]={RGB24;YUV420};
int fmts_nb=2, ret;
ret = cap->actions->set_cap_param(video_dev, fmts, fmts_nb);
//check return value and take appropriate action
}}}
After calling this method, all the members in `struct capture_device` will be set to their final value, reflecting the capture parameters that will be used:
 * the capture width is in `cap->width`, the height in `cap->height`,
 * the image format is `cap->palette`,
 * the video standard is `cap->std`,
 * the video channel is `cap->channel`
 * the image size is `cap->imagesize` (this value is only meaningful for uncompressed image formats. For compressed formats, the image size is returned when fetching the frame buffer)
This method returns 0 if successful, LIBVIDEO_ERR_FORMAT (no supplied image formats could be used), LIBVIDEO_ERR_STD (the supplied standard could not be used), LIBVIDEO_ERR_CHANNEL (the supplied channel is invalid), LIBVIDEO_ERR_CROP (error applying cropping parameters) or LIBVIDEO_ERR_NOCAPS (error checking capabilities).

== Initialise capture resources ==
This is done using:
{{{
int ret = cap->actions->init_capture(video_dev);
//check return value and take appropriate action
}}}
This function returns 0 if everything went fine, LIBVIDEO_ERR_REQ_MMAP if there was an error negotiating mmap params or LIBVIDEO_ERR_INVALID_BUF_NB if the number of requested buffers is incorrect.

== Start the capture ==
The hardware must be instructed to start capturing frames with:
{{{
int ret = cap->actions->start_capture(video_dev);
//check return value and take appropriate action
}}}
This method returns 0 if the capture was successfully started, LIBVIDEO_ERR_IOCTL otherwise.

== Get frame buffers ==
Images can now be obtained using:
{{{
int len;
unsigned int *buffer;
buffer = cap->actions->dequeue_buffer(video_dev, &len);
//check returned value
}}}
This method returns a pointer to a buffer containing the latest frame of length `len`, or NULL if there was an error getting the frame

== Return buffers ==
After processing, the buffer must be returned with:
{{{
cap->actions->enqueue_buffer(video_dev);
}}}
This function must be called after each successful call to `dequeue_buffer`.

== Stop the capture ==
The capture is stopped using:
{{{
int ret = cap->actions->stop_capture(video_dev);
//check return value
}}}
This method returns 0 if the capture is stopped, LIBVIDEO_ERR_IOCTL otherwise. At this point, the capture can be started again using `cap->actions->start_capture`. This function must be called if `start_capture()` was successful.

== Free resources ==
When finished, the capture resources must be freed using:
{{{
cap->actions->free_capture(video_dev);
}}}
This method must be called if `init_capture()` was successful.

= The Control interface =
= The Query interface =
= The Tuner interface =